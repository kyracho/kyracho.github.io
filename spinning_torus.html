<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spinning Torus Animation</title>
    <style>
        body {
            font-family: monospace;
            white-space: pre;
            line-height: 1.1em;
            background-color: black;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .matrix {
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="matrix" class="matrix"></div>
    <script>
        const canvasSize = 30;
        const canvas = Array(canvasSize).fill().map(() => Array(canvasSize).fill(' '));

        const R1 = 1; // Torus tube radius
        const R2 = 2; // Torus ring radius
        const K1 = canvasSize / (2 * (R1 + R2)); // Scaling factor
        const K2 = canvasSize * 2; // Distance factor

        let A = 0;
        let B = 0;

        function renderTorus() {
            const zBuffer = Array(canvasSize).fill().map(() => Array(canvasSize).fill(0));
            const chars = " .:-=+*#%@";
            const shades = [0, 0.1, 0.3, 0.5, 0.7, 0.9];
            const shadesChars = [" ", ".", ":", "-", "=", "+", "*", "#", "%", "@"];
            
            for (let j = 0; j < canvasSize; j++) {
                for (let i = 0; i < canvasSize; i++) {
                    canvas[j][i] = ' ';
                }
            }

            for (let theta = 0; theta < 2 * Math.PI; theta += 0.07) {
                for (let phi = 0; phi < 2 * Math.PI; phi += 0.02) {
                    const cosTheta = Math.cos(theta);
                    const sinTheta = Math.sin(theta);
                    const cosPhi = Math.cos(phi);
                    const sinPhi = Math.sin(phi);
                    const cosA = Math.cos(A);
                    const sinA = Math.sin(A);
                    const cosB = Math.cos(B);
                    const sinB = Math.sin(B);

                    const circleX = R2 + R1 * cosTheta;
                    const circleY = R1 * sinTheta;

                    const x = circleX * (cosB * cosPhi + sinA * sinB * sinPhi) - circleY * cosA * sinB;
                    const y = circleX * (sinB * cosPhi - sinA * cosB * sinPhi) + circleY * cosA * cosB;
                    const z = K2 + cosA * circleX * sinPhi + circleY * sinA;
                    const ooz = 1 / z;
                    const xp = Math.floor(canvasSize / 2 + K1 * x * ooz);
                    const yp = Math.floor(canvasSize / 2 - K1 * y * ooz);

                    const L = cosPhi * cosTheta * sinB - cosA * cosTheta * sinPhi - sinA * sinTheta + cosB * (cosA * sinTheta - cosTheta * sinA * sinPhi);

                    if (ooz > zBuffer[xp][yp]) {
                        zBuffer[xp][yp] = ooz;
                        const L_index = Math.floor((L + 1) * 5);
                        canvas[yp][xp] = shadesChars[L_index];
                    }
                }
            }

            const matrix = document.getElementById('matrix');
            matrix.textContent = canvas.map(row => row.join('')).join('\n');
        }

        function animate() {
            A += 0.04;
            B += 0.02;
            renderTorus();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
